<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.49">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206141707606.png"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PF50YMCFTR"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-PF50YMCFTR');</script><title>JavaScript | 一点一木前端进阶</title><meta name="description" content="一点一木的网站，专注与前端技术的分享！">
    <link rel="modulepreload" href="/blog/assets/app.65b6550c.js"><link rel="modulepreload" href="/blog/assets/JavaScript.html.ead57768.js"><link rel="modulepreload" href="/blog/assets/JavaScript.html.b6f573ff.js"><link rel="prefetch" href="/blog/assets/index.html.6bdf919a.js"><link rel="prefetch" href="/blog/assets/index.html.d055893c.js"><link rel="prefetch" href="/blog/assets/distance.html.50981d3a.js"><link rel="prefetch" href="/blog/assets/index.html.41c2bfa2.js"><link rel="prefetch" href="/blog/assets/base.html.5a72dd83.js"><link rel="prefetch" href="/blog/assets/canvas.html.067137aa.js"><link rel="prefetch" href="/blog/assets/experience.html.e5ddc513.js"><link rel="prefetch" href="/blog/assets/git.html.9259e06d.js"><link rel="prefetch" href="/blog/assets/pinia.html.06409671.js"><link rel="prefetch" href="/blog/assets/vite_vue3_ts.html.72418083.js"><link rel="prefetch" href="/blog/assets/vue3.html.a17f62f8.js"><link rel="prefetch" href="/blog/assets/GithubCopilot.html.5ab5eb8c.js"><link rel="prefetch" href="/blog/assets/index.html.76a50732.js"><link rel="prefetch" href="/blog/assets/recommend.html.9b24bd03.js"><link rel="prefetch" href="/blog/assets/tutorial.html.dae1f412.js"><link rel="prefetch" href="/blog/assets/index.html.8fc0df75.js"><link rel="prefetch" href="/blog/assets/honor.html.befcbd17.js"><link rel="prefetch" href="/blog/assets/index.html.b933f498.js"><link rel="prefetch" href="/blog/assets/css.html.7172fe34.js"><link rel="prefetch" href="/blog/assets/vue.html.f47afc39.js"><link rel="prefetch" href="/blog/assets/404.html.7d858b3d.js"><link rel="prefetch" href="/blog/assets/index.html.c2aa991d.js"><link rel="prefetch" href="/blog/assets/index.html.c2a903d7.js"><link rel="prefetch" href="/blog/assets/distance.html.bf5c3cda.js"><link rel="prefetch" href="/blog/assets/index.html.70ddf336.js"><link rel="prefetch" href="/blog/assets/base.html.3752748b.js"><link rel="prefetch" href="/blog/assets/canvas.html.a576087f.js"><link rel="prefetch" href="/blog/assets/experience.html.ea69f109.js"><link rel="prefetch" href="/blog/assets/git.html.b5a30e6e.js"><link rel="prefetch" href="/blog/assets/pinia.html.ae93577b.js"><link rel="prefetch" href="/blog/assets/vite_vue3_ts.html.f4cc8fdd.js"><link rel="prefetch" href="/blog/assets/vue3.html.a9bae806.js"><link rel="prefetch" href="/blog/assets/GithubCopilot.html.fe1fd084.js"><link rel="prefetch" href="/blog/assets/index.html.fcb93ec3.js"><link rel="prefetch" href="/blog/assets/recommend.html.d2ad20bd.js"><link rel="prefetch" href="/blog/assets/tutorial.html.e91f337a.js"><link rel="prefetch" href="/blog/assets/index.html.9ca995be.js"><link rel="prefetch" href="/blog/assets/honor.html.59c803e5.js"><link rel="prefetch" href="/blog/assets/index.html.646129ca.js"><link rel="prefetch" href="/blog/assets/css.html.74e3d910.js"><link rel="prefetch" href="/blog/assets/vue.html.7ece9132.js"><link rel="prefetch" href="/blog/assets/404.html.a14c78b8.js"><link rel="prefetch" href="/blog/assets/404.9f308604.js"><link rel="prefetch" href="/blog/assets/Layout.9e8e41b0.js">
    <link rel="stylesheet" href="/blog/assets/style.c50b481d.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/blog/" class=""><!----><span class="site-name">一点一木前端进阶</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/reference/" class="" aria-label="前端进阶"><!--[--><!--]--> 前端进阶 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/topic/" class="router-link-active" aria-label="面试宝典"><!--[--><!--]--> 面试宝典 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/software/" class="" aria-label="软件推荐"><!--[--><!--]--> 软件推荐 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/future/" class="" aria-label="前方的路"><!--[--><!--]--> 前方的路 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/chnjames" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/reference/" class="" aria-label="前端进阶"><!--[--><!--]--> 前端进阶 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/topic/" class="router-link-active" aria-label="面试宝典"><!--[--><!--]--> 面试宝典 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/software/" class="" aria-label="软件推荐"><!--[--><!--]--> 软件推荐 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/blog/future/" class="" aria-label="前方的路"><!--[--><!--]--> 前方的路 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/chnjames" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html" class="router-link-active router-link-exact-active router-link-active sidebar-item sidebar-heading active" aria-label="JavaScript"><!--[--><!--]--> JavaScript <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html#原型、构造函数、实例" class="router-link-active router-link-exact-active sidebar-item" aria-label="原型、构造函数、实例"><!--[--><!--]--> 原型、构造函数、实例 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#原型链" class="router-link-active router-link-exact-active sidebar-item" aria-label="原型链"><!--[--><!--]--> 原型链 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#class基本语法和继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="Class基本语法和继承"><!--[--><!--]--> Class基本语法和继承 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html#简介" class="router-link-active router-link-exact-active sidebar-item" aria-label="简介"><!--[--><!--]--> 简介 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#静态方法" class="router-link-active router-link-exact-active sidebar-item" aria-label="静态方法"><!--[--><!--]--> 静态方法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#实例属性的新写法" class="router-link-active router-link-exact-active sidebar-item" aria-label="实例属性的新写法"><!--[--><!--]--> 实例属性的新写法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#class的继承" class="router-link-active router-link-exact-active sidebar-item" aria-label="Class的继承"><!--[--><!--]--> Class的继承 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#对象的拷贝" class="router-link-active router-link-exact-active sidebar-item" aria-label="对象的拷贝"><!--[--><!--]--> 对象的拷贝 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#new运算符的执行过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="new运算符的执行过程"><!--[--><!--]--> new运算符的执行过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-对象" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise 对象"><!--[--><!--]--> Promise 对象 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html#含义" class="router-link-active router-link-exact-active sidebar-item" aria-label="含义"><!--[--><!--]--> 含义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#基本用法" class="router-link-active router-link-exact-active sidebar-item" aria-label="基本用法"><!--[--><!--]--> 基本用法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-prototype-then" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.prototype.then()"><!--[--><!--]--> Promise.prototype.then() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-prototype-catch" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.prototype.catch()"><!--[--><!--]--> Promise.prototype.catch() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-prototype-finally" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.prototype.finally()"><!--[--><!--]--> Promise.prototype.finally() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-all" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.all()"><!--[--><!--]--> Promise.all() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-race" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.race()"><!--[--><!--]--> Promise.race() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-allsettled" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.allSettled()"><!--[--><!--]--> Promise.allSettled() <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#promise-any" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise.any()"><!--[--><!--]--> Promise.any() <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#javascript执行机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="JavaScript执行机制"><!--[--><!--]--> JavaScript执行机制 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html#关于javascript" class="router-link-active router-link-exact-active sidebar-item" aria-label="关于JavaScript"><!--[--><!--]--> 关于JavaScript <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#javascript事件循环" class="router-link-active router-link-exact-active sidebar-item" aria-label="JavaScript事件循环"><!--[--><!--]--> JavaScript事件循环 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#array" class="router-link-active router-link-exact-active sidebar-item" aria-label="Array"><!--[--><!--]--> Array <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/blog/topic/JavaScript.html#script标签中defer和async的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="script标签中defer和async的区别"><!--[--><!--]--> script标签中defer和async的区别 <!--[--><!--]--></a><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/blog/topic/JavaScript.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a href="/blog/topic/vue.html" class="sidebar-item sidebar-heading" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a><!----></li><li><a href="/blog/topic/css.html" class="sidebar-item sidebar-heading" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true">#</a> JavaScript</h1><h2 id="原型、构造函数、实例" tabindex="-1"><a class="header-anchor" href="#原型、构造函数、实例" aria-hidden="true">#</a> 原型、构造函数、实例</h2><ul><li>原型（<code>prototype</code>）：一个简单的对象，用于实现对象的属性继承。</li><li>构造函数：可以通过<code>new</code>来新建一个对象的函数。</li><li>实例：通过构造函数和<code>new</code>创建出来的对象，便是实例。实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 实例</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// instance(实例).__proto__ === Object.prototype(原型)</span>

<span class="token comment">// Object.prototype(原型).constructor === Object(构造函数)</span>

<span class="token comment">// Object(构造函数).prototype === Object.prototype(原型)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206201957517.png" alt="Snipaste_2022-06-20_19-56-55"></p><h2 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链" aria-hidden="true">#</a> 原型链</h2><p>原型链是由原型对象组成，每个对象都有<code>__proto__</code>属性，指向了创建该对象的构造函数的原型，<code>__proto__</code>将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。</p><ul><li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加改属性，如果需要修改原型的属性时，则可以用：<code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h2 id="class基本语法和继承" tabindex="-1"><a class="header-anchor" href="#class基本语法和继承" aria-hidden="true">#</a> <code>Class</code>基本语法和继承</h2><h3 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="constructor-方法" tabindex="-1"><a class="header-anchor" href="#constructor-方法" aria-hidden="true">#</a> <code>constructor</code> 方法</h4><p><code>constructor()</code> 方法是类的默认方法，通过<code>new</code> 命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显示定义，一个空的<code>constructor()</code>方法会被默认添加。<code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><p>类必须使用<code>new</code> 调用，否则会报错。</p><h4 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h4><ul><li><p>严格模式</p><p>类和模块的内部，默认就是严格模式。只要你写的代码在类或模块之中，就是严格模式。</p></li><li><p>不存在提升</p><p>类不存在变量提升。</p></li><li><p><code>name</code>属性</p><p>由于本质上，<code>ES6</code>的类只是<code>ES5</code>的构造函数的一层包装，所以函数的需要特性都被<code>class</code>继承，包括<code>name</code>属性。</p></li><li><p><code>Generator</code>方法</p><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个<code>Generator</code>函数。</p></li><li><p><code>this</code>的指向</p><p>类的方法内部如果含有<code>this</code>，他默认指向类的实例。</p></li></ul><h3 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法" aria-hidden="true">#</a> 静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用。</p><p>父类的静态方法，可以被子类继承。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&#39;, too&#39;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Bar<span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;hello, too&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实例属性的新写法" tabindex="-1"><a class="header-anchor" href="#实例属性的新写法" aria-hidden="true">#</a> 实例属性的新写法</h3><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。此时，不需要再实例属性前面加上<code>this</code>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">IncreasingCounter</span> <span class="token punctuation">{</span>
  _count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_count<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="class的继承" tabindex="-1"><a class="header-anchor" href="#class的继承" aria-hidden="true">#</a> <code>Class</code>的继承</h3><p><code>Class</code>可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类的constructor(x, y)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ES6</code>规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>。因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p><h2 id="对象的拷贝" tabindex="-1"><a class="header-anchor" href="#对象的拷贝" aria-hidden="true">#</a> 对象的拷贝</h2><ul><li>浅拷贝：以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 <ul><li><code>Object.assign</code></li><li>展开运算符（<code>...</code>）</li></ul></li><li>深拷贝：完全拷贝一个新对象，修改时原对象不再受到任何影响 <ul><li><code>JSON.parse(JSON.stringify(obj))</code>：性能最快 <ul><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>或<code>Symbol</code>时，无法拷贝</li></ul></li><li>递归进行逐一赋值</li></ul></li></ul><h2 id="new运算符的执行过程" tabindex="-1"><a class="header-anchor" href="#new运算符的执行过程" aria-hidden="true">#</a> <code>new</code>运算符的执行过程</h2><ul><li>新生成一个对象</li><li>链接到原型：<code>obj.__proto__ = Con.prototype</code></li><li>绑定<code>this</code>：<code>apply</code></li><li>返回新对象（如果构造函数有自己的return时，则返回该值）</li></ul><h2 id="promise-对象" tabindex="-1"><a class="header-anchor" href="#promise-对象" aria-hidden="true">#</a> <code>Promise</code> 对象</h2><h3 id="含义" tabindex="-1"><a class="header-anchor" href="#含义" aria-hidden="true">#</a> 含义</h3><p>异步编程的一种解决方案。简单来说，就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>从语法上来说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。</p><p><code>Promise</code> 对象有以下两个特点：</p><ul><li>对象的状态不受外界影响。<code>Promise</code> 对象代表一个异步操作，有三种状态：<code>pending</code>进行中、<code>fulfilled</code>已完成和<code>rejected</code>已失败。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变，就不会再变，任何时候都可以得到折耳结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li></ul><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法" aria-hidden="true">#</a> 基本用法</h3><p>ES6规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token comment">// ... some code</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="promise-prototype-then" tabindex="-1"><a class="header-anchor" href="#promise-prototype-then" aria-hidden="true">#</a> <code>Promise.prototype.then()</code></h3><p><code>Promise</code> 实例具有 <code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象 <code>Promose.prototype</code>上的。它的作用是为<code>Promise</code>实例添加状态改变时的回调函数。</p><h3 id="promise-prototype-catch" tabindex="-1"><a class="header-anchor" href="#promise-prototype-catch" aria-hidden="true">#</a> <code>Promise.prototype.catch()</code></h3><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><h3 id="promise-prototype-finally" tabindex="-1"><a class="header-anchor" href="#promise-prototype-finally" aria-hidden="true">#</a> <code>Promise.prototype.finally()</code></h3><p><code>finally()</code>方法用于指定不管<code>Promise</code>对象最后的状态如何，都会执行的操作。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>promise
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="promise-all" tabindex="-1"><a class="header-anchor" href="#promise-all" aria-hidden="true">#</a> <code>Promise.all()</code></h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const p = Promise.all([p1, p2, p3])
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总结：全部子实例成功才成功，一个子实例失败就失败。</p><h3 id="promise-race" tabindex="-1"><a class="header-anchor" href="#promise-race" aria-hidden="true">#</a> <code>Promise.race()</code></h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总结：<code>race</code>是赛跑机制，看最先子实例是成功还是失败。</p><h3 id="promise-allsettled" tabindex="-1"><a class="header-anchor" href="#promise-allsettled" aria-hidden="true">#</a> <code>Promise.allSettled()</code></h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总结：所有子实例执行完成，无论成功或失败。</p><h3 id="promise-any" tabindex="-1"><a class="header-anchor" href="#promise-any" aria-hidden="true">#</a> <code>Promise.any()</code></h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>总结：有一个子实例成功就成功，全部子实例失败才失败。</p><h2 id="javascript执行机制" tabindex="-1"><a class="header-anchor" href="#javascript执行机制" aria-hidden="true">#</a> <code>JavaScript</code>执行机制</h2><h3 id="关于javascript" tabindex="-1"><a class="header-anchor" href="#关于javascript" aria-hidden="true">#</a> 关于<code>JavaScript</code></h3><p><code>JavaScript</code>是一门<strong>单线程</strong>语言，在最新的HTML5中提出了<code>web-Worker</code>，但<code>JavaScript</code>是单线程这一核心仍未改变。</p><h3 id="javascript事件循环" tabindex="-1"><a class="header-anchor" href="#javascript事件循环" aria-hidden="true">#</a> <code>JavaScript</code>事件循环</h3><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206211106951.png" alt="image-20220621110631637"></p><ul><li>同步任务和异步任务分别进入不同的执行“场所”。同步的进入主线程，异步的进入<code>Event Table</code>并注册函数。</li><li>当指定的事情完成时，<code>Event Table</code>会将这个函数移入<code>Event Queue</code>。</li><li>主线程内的任务执行完毕为空，会去<code>Event Queue</code>读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的<code>Event Loop</code>（事件循环）。</li></ul><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li><code>macro-task(宏任务)</code>：包括整体代码<code>script</code>、<code>setTimeout</code>、<code>setInterval</code></li><li><code>micro-task(微任务)</code>：<code>Promise</code>、<code>process.nextTick</code>、<code>Ajax</code></li></ul><p>不同类型的任务会进入对应的<code>Event Queue</code>，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的<code>Event Queue</code>。</p><p><strong>事件循环、宏任务、微任务的关系：</strong></p><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206211655498.png" alt="image-20220621165533617"></p><h2 id="array" tabindex="-1"><a class="header-anchor" href="#array" aria-hidden="true">#</a> <code>Array</code></h2><ul><li><code>map</code>：遍历数组，返回回调返回值组成的新数组</li><li><code>forEach</code>：无法<code>break</code>，可以用<code>try / catch</code>中<code>throw new Error</code>来停止</li><li><code>filter</code>：过滤</li><li><code>some</code>：有一项返回<code>true</code>，则整体为<code>true</code></li><li><code>every</code>：有一项返回<code>false</code>，则整体为<code>false</code></li><li><code>join</code>：通过指定连接符生成字符串</li><li><code>push / pop</code>：末尾推入和弹出，改变原数组，<code>push</code>返回数组长度，<code>pop</code>返回原数组最后一项；</li><li><code>unshift / shift</code>：头部推入和弹出，改变原数组，<code>unshift</code>返回数组长度，<code>shift</code>返回原数组第一项；</li><li><code>sort(fn) / reverse</code>：排序与反转，改变原数组</li><li><code>concat</code>：连接数组，不影响原数组，浅拷贝</li><li><code>slice(start, end)</code>：返回截取后的新数组，不改变原数组</li><li><code>splice(start, number, value...)</code>：返回删除元素组成的数组，value为插入项，改变原数组</li><li><code>indexOf / lastIndexOf(value, fromIndex)</code>：查找数组项，返回对应的下标</li><li><code>reduce / reduceRight(fn(prev, cur), defaultPrev)</code>：两两执行，<code>prev</code>为上次化简函数的<code>return</code>值，<code>cur</code>为当前值 <ul><li>当传入<code>defaultPrev</code>时，从第一项开始</li><li>当未传入时，则为第二项</li></ul></li></ul><h2 id="script标签中defer和async的区别" tabindex="-1"><a class="header-anchor" href="#script标签中defer和async的区别" aria-hidden="true">#</a> <code>script</code>标签中<code>defer</code>和<code>async</code>的区别</h2><ul><li><p><code>script</code>：会阻碍<code>HTML</code>解析，只有下载好并执行完脚本才会继续解析<code>HTML</code>。</p><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206251639337.svg" alt="script"></p></li><li><p><code>script async</code>：解析<code>HTML</code>过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断<code>HTML</code>的解析。</p><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206251643291.svg" alt="script-async"></p></li><li><p><code>script defer</code>：完全不会阻碍<code>HTML</code>的解析，解析完成之后再按照顺序执行脚本。</p><p><img src="https://raw.githubusercontent.com/chnjames/cloudImg/main/blog/202206251644746.svg" alt="script-defer"></p></li></ul><blockquote><p><code>defer</code>和<code>async</code>特性仅适用于外部脚本。</p><p>如果<code>&lt;script&gt;</code>脚本没有<code>src</code>，则会忽略<code>defer</code>和<code>async</code>特性。</p></blockquote><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><code>async</code>和<code>defer</code>共同点：加载脚本都不会阻塞页面的渲染。</p><p>区别：</p><table><thead><tr><th></th><th>顺序</th><th><code>DOMContentLoaded</code></th></tr></thead><tbody><tr><td><code>async</code></td><td><strong>加载优先顺序</strong>。脚本在文档中的顺序不重要---先加载完成的先执行</td><td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或来自于缓存，同时文档足够长，就会发生这种情况。</td></tr><tr><td><code>defer</code></td><td><strong>文档顺序</strong>（它们在文档中的顺序）</td><td>在文档加载和解析完成之后（如果需要，则会等待），即在<code>DOMContentLoaded</code>之前执行。</td></tr></tbody></table><p>在实际开发中，<code>defer</code>用于需要整个<code>DOM</code>的脚本和脚本的相对执行顺序很重要的时候。<code>async</code>用于独立脚本，例如计数器或广告，这些脚本的相对执行顺序无关紧要。</p><blockquote><p>如果你使用的是<code>defer</code>或<code>async</code>，那么用户将在脚本加载完成之前先看到页面。在这种情况下，某些图形组件可能尚未初始化完成。因此，请记得添加一个“正在加载”的提示，并禁用尚不可用的按钮。以让用户可以清楚地看到，他现在可以在页面上做什么，以及还有什么是正在准备中的。</p></blockquote></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: chnrural910@gmail.com">一点一木</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/blog/topic/vue.html" class="" aria-label="Vue"><!--[--><!--]--> Vue <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.65b6550c.js" defer></script>
  </body>
</html>
